## 来自你的消息
你知道 GDC 演讲 AI-Navigation-It-s-Not 吗？
<environment_details>
# Current Time
1/27/2026, 12:37:00 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
知道。这是 GDC 上一类关于**游戏 AI 导航（Navigation）**的演讲，标题用 “It’s Not …” 这种反差句式来强调一个观点：**“导航”在实际项目里远不只是‘寻路（A*）+ NavMesh’**，真正难的是把导航系统做成**可落地、可维护、可调试、能适配关卡变化与角色能力**的一整套工程体系。

通常这类演讲会集中讲这些痛点/主题（不同年份/讲者细节会有差异，但核心问题高度一致）：

- **NavMesh 不是万能**：动态障碍、可破坏场景、门/电梯/跳跃/攀爬等“非平面行走”能力，往往需要 NavLink、分层图、Smart Object、或自定义代价模型来补齐。
- **“能走”不等于“会走得像人”**：局部避障（RVO/Detour Crowd）、队形、拥挤、让路、转身半径、动画根运动约束等，决定了最终观感。
- **调试与可视化是生产力**：路径为何失败、代价为何异常、哪个区域被标记不可达、动态更新是否生效——没有可视化/日志/回放工具会非常痛苦。
- **导航是跨系统问题**：AI、动画、物理、关卡、美术、网络同步都会影响导航；很多 bug 不是算法问题，而是数据/流程问题。
- **性能与增量更新**：大世界、流式加载、运行时修改导航数据时，如何做 tile 化、异步构建、分帧更新、以及“只更新必要部分”。

如果你想确认我说的是**哪一场具体演讲**，你把以下任意信息发我一个就行，我可以更精确地对齐内容并总结要点：
1) 年份（哪届 GDC）  
2) 讲者/公司  
3) 公开视频链接或完整标题截图/文字

## 来自你的消息
在 UE 中，同时30个character寻路就卡的不行，移动的计算代价太高，又因为所有的角色计算移动路径是相同cast和导航网格，所以只要终点相同，起点相近，就一定会出现互相拥挤的情况
为了解决这两个问题，通常应该怎么处理？请提出解决方案，比举出该方案的实际用例
<environment_details>
# Current Time
1/27/2026, 1:01:04 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
下面把你的两个问题拆开：**(1) 30 个 Character 同时寻路卡**（CPU/导航查询开销大），**(2) 终点相同起点相近导致拥挤**（群体行为/局部避障与“同一路径”问题）。UE 里通常用“分层导航 + 共享/复用 + 群体局部避障 + 目标分配/排队”组合拳解决。

---

## 1) 降低“同时寻路”的计算代价（让 30 个不再同时做重活）

### 方案 A：路径复用（Path Sharing / Path Cache）
**思路**：同一 NavMesh、同一目标点、起点相近时，不要每个单位都跑一遍完整 A*。让“领队”算一条主路径，其它单位复用主路径的“走廊”，只在局部做微调（或只算到主路径的接入点）。

**怎么做（UE 常见做法）**
- 在 AIController/Manager 里做一个 **Path Cache**：key 可以是 `(NavData, GoalLocation(量化), AreaMask, FilterClass)`。
- 新请求进来时，如果与缓存目标足够接近、且起点在主路径走廊附近：  
  - 直接复用缓存路径（或复用路径点序列），只做 `FindPathToLocationSynchronously` 的“短接入段”。
- 缓存设置 TTL（几百毫秒到几秒）+ 目标移动时失效。

**实际用例**
- RTS/塔防：一波 50 个小兵冲同一个门。只让每波/每小队算一次全局路径，其余复用，CPU 从“50 次 A*”降到“1 次 A* + 49 次轻量接入/跟随”。

---

### 方案 B：分层导航（Hierarchical Pathfinding / HPA* 思路）
**思路**：远距离用粗图（区域/门洞/路网）算一次，近距离才在 NavMesh 上细化。UE 的 Recast/Detour 本身就有分层/瓦片化能力，但你可以在玩法层再加一层“路网/航点图”。

**怎么做**
- 关卡里放“路网节点”（路口、门、桥头），预计算连通与代价。
- AI 先在路网图上算“宏路径”（节点序列），再对当前段做短距离 NavMesh 路径。
- 宏路径可复用、可缓存，且对动态障碍不敏感（动态障碍交给局部避障）。

**实际用例**
- 开放世界巡逻：NPC 从城门到市场很远。宏路径只算一次，细化只算当前 20–40 米，避免每次都在大范围 NavMesh 上搜索。

---

### 方案 C：寻路节流与异步（Budgeting / Staggering）
**思路**：你卡往往是“同一帧 30 个一起算”。把寻路请求做成队列，每帧只处理 N 个，或按距离/重要性分级。

**怎么做**
- 建一个 `NavigationRequestManager`：  
  - 每帧预算：例如最多 2~5 次完整寻路，其余延后。  
  - 远处/不可见/低优先级单位降低更新频率（0.2s~1s 才重算一次）。
- 目标不变时不要频繁 `MoveTo` 触发重算；设置合理的 `AcceptanceRadius`，减少“抖动重算”。

**实际用例**
- 30 个敌人追玩家：屏幕外的敌人只做低频更新，屏幕内的才高频，帧时间稳定很多。

---

## 2) 解决“终点相同导致拥挤”（让他们别都挤同一条线/同一个点）

### 方案 D：局部避障/人群系统（Detour Crowd / RVO）
**思路**：全局路径相同没关系，**局部避障**负责在路径走廊内“错开、让路、绕开同伴”，避免互相推挤卡死。

**怎么做（UE 常用）**
- 对大量单位，优先考虑 **Detour Crowd**（`UCrowdFollowingComponent` / Crowd Manager）而不是纯 `UPathFollowingComponent`。
- 或启用 `CharacterMovementComponent` 的 **RVO Avoidance**（适合中小规模，但要调参数）。
- 关键参数：代理半径、最大加速度、分离权重、避障质量、更新频率。

**实际用例**
- 城市场景 30 个行人走向同一出口：全局路径都指向门，但门口会自动形成“流”，而不是互相顶住。

> 注意：局部避障解决的是“走廊内的碰撞与让路”，但**不解决“同一个终点点位”**（大家都想站在同一像素）的问题，所以还需要目标分配。

---

### 方案 E：目标点分配（Slot / Formation / Ring Targets）
**思路**：不要让 30 个都 `MoveTo(同一个点)`。把“终点”变成一组可占用的 **slot**（环形、扇形、队形、网格），每个单位拿一个不同的 slot。

**怎么做**
- 以目标点为中心生成一圈/多圈 slot（半径按单位半径+间距）。
- 用简单的分配策略：  
  - 最近者优先、匈牙利算法（最小总路程）、或按小队分扇区。
- slot 被占用/释放要管理（到达后锁定，死亡/离开释放）。

**实际用例**
- 近战怪围殴玩家：每个怪分配一个“围绕玩家的站位点”，看起来像包围而不是一坨挤在玩家正前方。

---

### 方案 F：排队/门洞流量控制（Queue / Bottleneck Controller）
**思路**：门、桥、梯子这种瓶颈处，局部避障也可能抖动。给瓶颈加“通行规则”：一次放行几个、其余在等待区排队。

**怎么做**
- 在瓶颈前放 `SmartObject`/触发器：进入后申请“通行 token”。
- 没拿到 token 的单位 MoveTo 等待点（多个等待 slot），拿到后再 MoveTo 通过点。
- 通过后释放 token。

**实际用例**
- 30 个 AI 过一扇窄门：不会在门口互相推挤，而是像真实人群一样排队通过。

---

## 推荐的“组合落地方案”（最常见、性价比最高）
如果你现在就是“30 个追同一目标点”：

1. **目标点改为 Slot 分配**（立刻解决“挤成一团”根因）  
2. **启用 Crowd/RVO 做局部避障**（解决走廊内互相让路）  
3. **寻路做节流 + 路径缓存**（解决同帧 30 次寻路卡顿）  
4. 仍然远距离卡：再上 **分层导航/宏路径**（大地图收益最大）

---

## 我需要你补两点信息，才能给你更具体的 UE 参数/组件建议
1) 你用的是 `AI MoveTo` + `CharacterMovement` 吗？有没有启用 Crowd（`UCrowdFollowingComponent`）或 RVO？  
2) 卡顿主要在 **寻路（FindPath）** 还是 **移动/避障（Tick/MovementComponent）**？你可以用 `stat unit`、`stat ai`、`stat navigation` 看一下热点。

你把这两点回我，我就按你的现状给一套“最小改动”的具体配置清单（包括该开哪些开关、哪些参数范围、以及 slot 生成/分配的实现思路）。

## 来自你的消息
在我看来 寻路 是路径规划做的事情，避障则属于角色行为，如果要自己实现一些避障逻辑，比如当一个角色A穿过一群围在一起的角色的时候，会把自己路径上的角色向两边推，被推的角色会继续推自己前进方向的角色，直到角色A穿过人群，被推开的角色返回原位，应该如何实现呢？请详细说明解决方案
<environment_details>
# Current Time
1/27/2026, 1:31:39 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
你描述的是一种“**可穿行的人群挤开**”效果：角色 A 不是绕开人群，而是像“楔子/推土机”一样把前方单位挤到两侧；被挤开的单位会把挤压继续传递（链式推挤），A 通过后人群再“回弹”到原位/回到队形。这类效果用纯导航/纯 RVO 很难做得稳定，通常要做成**局部人群模拟 + 约束/弹簧回位 + 推挤传播**。

下面给你一套在 UE 里可落地的实现方案（偏工程化），并说明关键数据结构、每帧流程、以及如何避免抖动/穿模。

---

## 总体思路：把“人群”当作可变形的局部系统
把每个被挤开的角色 \(i\) 看成有一个“期望位置” \(P_i^{base}\)（它原本应该站的位置：队形 slot、巡逻点、或当前路径跟随点），以及一个“当前偏移” \(d_i\)。  
A 通过时，你不是直接改它们的导航路径，而是对它们施加一个**横向位移约束**（push offset），并用弹簧把它们拉回 \(P_i^{base}\)。

关键点：
- **推挤是局部的**：只影响 A 前方一定范围内的人。
- **推挤是横向的**：尽量沿着 A 的前进方向的法线把人分到两侧，而不是把人往前推（往前推会造成“推着推着全队漂移”）。
- **推挤可传播**：如果某个角色被推到会撞到另一个角色，就把推力/位移继续传给下一个（链式）。
- **回位是渐进的**：A 离开后，偏移通过弹簧/阻尼回到 0，避免瞬间弹回穿模。

---

## 组件划分（建议）
### 1) `UCrowdPushAgentComponent`（挂在每个可被挤开的角色上）
保存并更新：
- `BaseLocation`：该角色“应该在的位置”（slot/路径跟随点/当前站位）
- `Offset`：当前被挤开的偏移（世界空间或局部空间）
- `VelocityOffset`：偏移速度（用于弹簧）
- `bIsBeingPushed`、`LastPushedTime`
- 参数：`MaxOffset`、`SpringK`、`DampingC`、`MaxOffsetSpeed`

它负责两件事：
1. **被推时**：接收一个“目标偏移/推力”，融合到 `Offset/VelocityOffset`
2. **不推时**：把 `Offset` 用弹簧拉回 0（回到 `BaseLocation`）

### 2) `UCrowdPusherComponent`（挂在角色 A 上）
负责每帧：
- 找到 A 前方的受影响角色集合
- 计算“应该往哪边挤开多少”
- 做推挤传播（链式）
- 把结果写入每个 `UCrowdPushAgentComponent`

---

## 每帧算法流程（核心）

### Step 0：确定“基准位置” \(P_i^{base}\)
你必须先定义“原位”是什么，否则“返回原位”无从谈起。常见来源：
- **队形/包围 slot**：最稳定（推荐）
- **当前 MoveTo 的路径跟随点**：也可以，但会随路径变化抖动
- **站立时的初始位置**：只适合静止人群

工程上最常用：**人群/小队系统给每个单位一个 slot**，slot 的世界位置就是 `BaseLocation`。

---

### Step 1：收集 A 前方的候选人群
用一个“推挤走廊”来筛选：
- 以 A 的位置为起点，沿 A 的前进方向 \(F\) 做一个胶囊/盒体（长度 L，宽度 W）
- 只取在走廊内、且与 A 高度层相近的角色
- 只取“可被推开”的角色（同阵营/中立/允许穿行的 tag）

UE 实现上可以用：
- `SphereOverlapActors` + 方向/投影过滤
- 或 `BoxOverlap`（更贴合走廊）

---

### Step 2：为每个候选角色计算“横向分离目标”
对每个角色 \(i\)：
1. 计算它相对 A 的向量 \(r = P_i - P_A\)
2. 计算前向投影 \(s = dot(r, F)\)，只处理 \(0 < s < L\)
3. 计算横向分量 \(t = dot(r, R)\)，其中 \(R\) 是 A 的右向量（或 \(R = normalize(cross(Up, F))\)）
4. 设定“希望它离中线的目标横向距离”：
   \[
   t_{target} = sign(t)\cdot (Radius_A + Radius_i + Margin)
   \]
   如果 \(t\) 接近 0（在正中间），用一个规则决定左右（例如：按角色 ID 奇偶、或按离左/右边界更近）。

5. 得到需要的横向位移：
   \[
   \Delta t = clamp(t_{target} - t,\ -MaxStep,\ MaxStep)
   \]
6. 推挤向量：
   \[
   Push = R \cdot \Delta t
   \]
把这个 `Push` 作为该角色本帧的“目标偏移增量”。

> 这里的关键是：**只推横向**，并且每帧有 `MaxStep` 限制，避免瞬移穿模。

---

### Step 3：推挤传播（链式推挤）
你想要“被推的角色继续推前进方向的角色”，本质是：当角色 i 被推到新位置后，如果它与邻居 j 发生重叠，就把重叠解决量传递给 j。

做法（稳定且易控）：
- 把候选角色按 \(s\)（沿 A 前进方向的投影）排序：从近到远
- 依次处理每个角色 i：
  - 先应用它的 `Push` 得到一个“预测位置” \(P_i'\)
  - 在 \(P_i'\) 附近查找与它可能重叠的角色 j（通常只需要查同一走廊内、且 \(s_j > s_i\) 的“前方角色”）
  - 若距离 \(dist(P_i', P_j') < (Radius_i + Radius_j)\)，计算最小分离向量 `Sep`（仍然优先横向，必要时少量前向）
  - 把 `Sep` 的一部分加到 j 的 push 上（例如 70% 传递，30% 自己承担），形成“推挤波”
- 这相当于做一次“单向约束求解”（类似简化版 PBD/Position Based Dynamics），成本可控。

> 你要的“继续推自己前进方向的角色”可以理解为：**推挤影响沿队列向前传播**，排序 + 只向前传递能避免循环震荡。

---

### Step 4：把推挤结果写入每个被推角色（并做回位）
对每个被推角色 i：
- `Offset += Push`（或把 Push 作为 `TargetOffset`，用插值/弹簧追过去）
- 标记 `bIsBeingPushed = true`，更新 `LastPushedTime`

对未被推的角色：
- 如果 `Now - LastPushedTime > ReleaseDelay`，开始回位：`Offset -> 0`（弹簧）

**回位推荐用二阶弹簧（带阻尼）**，比简单插值自然且不抖：
- 目标：`OffsetTarget = 0`
- 更新 `VelocityOffset` 与 `Offset`（每帧）
- 最后把角色的“期望位置”设为：
  \[
  P_i^{desired} = P_i^{base} + Offset
  \]

---

## UE 里“怎么让角色真的移动到 \(P^{desired}\)”（两种路线）

### 路线 1（推荐）：不改导航路径，只改“局部移动目标”
- 角色仍然按原来的 MoveTo/队形逻辑走
- 但在 `Tick` 里把 `AddMovementInput` 的期望方向改成指向 \(P^{desired}\)
- 或者对 `PathFollowingComponent` 做一个“局部偏移”层：把当前路径点加上 `Offset`

优点：不会频繁触发重寻路；推挤是纯局部行为层。

### 路线 2：用物理/碰撞推开（不推荐作为主方案）
- 让 A 开启更强的碰撞推力，其他人可被推
- 但会出现：网络同步难、抖动、堆叠、门口卡死、以及“回原位”很难保证

---

## 关键工程细节（决定成败）
1. **必须有 BaseLocation（slot/队形）**：否则“回原位”会变成回到一个不断变化的点，抖动很明显。  
2. **推挤只在局部走廊内生效**：否则会把整个队伍“挤散”。  
3. **横向优先，前向为辅**：前向推会导致整体漂移；只有在横向无空间（靠墙）时才允许少量前向/后向。  
4. **墙体/不可走区域约束**：推到两侧时要用 NavMesh 投影或简单射线，确保 \(P^{desired}\) 仍在可行走区域；否则会把人推到墙里。  
5. **传播要单向/有限迭代**：避免循环推挤导致震荡。一般 1 次排序传播 + 必要时 2 次迭代就够。  
6. **网络**：多人游戏建议“服务器权威”计算 Offset，客户端只插值显示；否则会不同步。

---

## 实际用例（你这个效果最常见的落地场景）
- **玩家/精英怪“冲锋穿人群”**：冲锋单位 A 具有“人群穿行权”，普通小兵被挤开形成通道，冲锋结束后小兵回到包围圈 slot。  
- **护送/人群疏散**：VIP 走过拥挤人群，人群自动让出一条路，随后回到原来的站位/队列。  
- **RTS 大单位穿过小单位**：大单位不绕路，直接挤开小兵，小兵回到编队格子。

---

## 你如果愿意，我可以把方案进一步“落到 UE 具体实现点”
为了给你更贴近你项目的实现细节，我需要你确认三点（会影响选型）：
1) 被推开的角色是 `Character` 还是自定义 `Pawn`？是否用 `CharacterMovementComponent`？  
2) 你希望“被推开时”他们还能继续执行原本的 MoveTo/攻击行为吗，还是短暂进入“让路状态”？  
3) 这是单机还是联机（是否需要网络同步）？

你回这三点后，我可以按你的情况给出：组件挂载位置、Tick 顺序、Overlap 查询方式、以及一套参数初值范围（L/W、SpringK/Damping、MaxOffset 等）。

## 来自你的消息
现在我要再加上一个设定，有些角色可以被推动，有些角色不能被推动，此时要穿越人群的角色A的路径规划应该如何做？注意 人群和角色A 应该是相同类的角色，因为都有可能被推开或者推开别人
另外不可被推开的角色不能作为路径不可达，因为虽然不可被推开，但是他可以移动，因为他是角色
<environment_details>
# Current Time
1/27/2026, 1:38:24 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
你这个设定本质上把“人群”分成两类动态代理：

- **Soft（可被推开）**：可以让路/被挤开，等价于“可穿行但有代价/会扰动”  
- **Hard（不可被推开）**：不会被挤开，但它仍然是会走的角色，所以**不能当成静态障碍把 NavMesh 切断**；同时它对 A 来说又不是“空气”，因为会造成局部阻塞/碰撞风险

因此 A 的路径规划不能再是“把 Hard 当墙、Soft 当空气”这种二元模型，而要做成：  
**全局规划仍走 NavMesh（忽略动态角色），局部层用“动态代价 + 预测占用 + 行为协商”来决定穿越/绕行/等待。**

下面给你一套可落地的做法，满足你提出的约束：同一类角色、可互相推/不可推、Hard 不是不可达。

---

## 1) 给每个角色定义“可推性/优先级”与“让路策略”
在同一个 Character 类里加一组属性（概念上）：

- `PushMode`：`Soft` / `Hard`
- `PushStrength`：推开别人的能力（0 表示不会推别人）
- `YieldPriority`：让路优先级（数值越低越不让）
- `CanPhaseThroughSoft`：是否允许穿越 Soft 人群（例如冲锋/体型大）
- `MaxWaitTimeBeforeReplan`：等待多久改道

这样 A 既可能是 Soft 也可能是 Hard（或强推者），逻辑统一。

---

## 2) 路径规划分两层：NavMesh 全局 + 动态人群局部决策
### 2.1 全局路径（NavMesh）不要把角色烘焙成障碍
原因你已经说了：Hard 角色会移动，若把它当不可达会导致“明明过一会就能走却绕很远/甚至无路”。

所以全局层：
- 仍然 `MoveTo` 到目标（或到 slot）
- 不把动态角色写进 NavMesh（除非是“超大、近似建筑”的单位）

### 2.2 局部层：在“下一段路径走廊”里做动态评估
A 每隔 \(T\)（比如 0.1–0.3s）对**前方走廊**做一次评估，决定三种策略之一：

1) **Push-Through（挤过去）**：前方主要是 Soft，或 A 的 PushStrength 足够  
2) **Bypass（绕行）**：前方 Hard 密度高，绕开更划算  
3) **Wait/Negotiate（等待/协商）**：Hard 在前方但预计会移动走（例如正在走向别处），短等比绕行好

这一步是关键：Hard 不是不可达，但会让“穿越成本”变高；如果成本太高就绕行或等待。

---

## 3) 如何把“Hard/Soft 人群”变成可用于决策的量：动态代价场（Cost Field）
你需要一个“局部代价模型”，把前方人群转成一个标量成本，用来判断“继续走当前路径 vs 触发局部绕行/重规划”。

### 3.1 走廊采样
沿 A 当前路径的前方距离 \(L\)（比如 5–15m）取若干采样点 \(x_k\)。

### 3.2 对每个采样点计算人群代价
对附近角色 \(j\) 叠加一个代价核（类似势场）：

- Soft 角色：代价低（因为能推开），但不是 0（推开会扰动、会减速）
- Hard 角色：代价高（因为不能推开，容易卡住），但仍有限（因为它会走，且可以等待）

示意：
\[
Cost(x) = \sum_{j \in Soft} w_s \cdot \phi(\|x - p_j\|) + \sum_{j \in Hard} w_h \cdot \phi(\|x - p_j\|)
\]
其中 \(w_h \gg w_s\)，\(\phi\) 是随距离衰减的核（高斯/反比/分段线性都行）。

再加一个“相对运动”修正：如果 Hard 正在远离走廊，代价降低；如果正横穿/迎面，代价升高。

### 3.3 用代价决定策略
- 若前方累计代价 < 阈值：继续走 + 启用推挤（对 Soft 生效）
- 若代价主要来自 Hard 且持续时间长：触发绕行（局部重规划）
- 若代价来自少量 Hard 且其速度方向显示“很快离开”：等待 \(t\) 秒再走

这就满足：Hard 不会让路径“不可达”，但会让“通过成本”变高，从而触发等待/绕行。

---

## 4) “绕行”怎么做：局部重规划到一个临时中间点（而不是全局重算）
因为动态人群变化快，你不想每次都全局 A*。

做法：
1) 在 A 前方扇形区域（例如 \(\pm 60^\circ\)，半径 3–8m）采样若干候选中间点 \(c_i\)（投影到 NavMesh）
2) 对每个候选点计算评分：
   - 到目标的导航距离（越短越好）
   - 走廊人群代价（越低越好）
   - 转向代价（越小越好，避免抖动）
3) 选最优 \(c^*\)，让 A `MoveTo(c^*)`，到达或代价下降后再回到原目标

这相当于“动态避障的局部绕行器”，Hard 角色不需要变成障碍体也能绕开。

---

## 5) “Push-Through”时 Soft/Hard 的交互规则（避免硬推硬导致穿模/抖动）
当 A 进入推挤模式：
- **只对 Soft 施加推挤传播**（你上一问的链式推挤）
- 遇到 Hard：
  - A 不尝试推它（PushStrength 对 Hard 无效）
  - A 的局部 steering 产生一个“侧向偏置”尝试从 Hard 旁边挤过去
  - 如果连续 \(t\) 秒前进速度低于阈值（卡住检测），切换到“绕行/等待”

这样 Hard 仍然是“可通过的动态体”（因为它会走），但不会被你强行挤开。

---

## 6) “同类角色”如何统一：用“能力矩阵”而不是固定身份
因为每个角色都可能是 A，也可能是人群成员，所以规则必须对称/可组合。建议用一个简单矩阵：

- `CanPush(Other)`：是否能推开对方（Soft/Hard + 阵营/状态）
- `ShouldYieldTo(Other)`：是否应该让路（优先级/任务重要性）
- `YieldBehavior`：让路时是“侧移到 slot”还是“停下等待”还是“后退”

例如：
- 运输车（Hard）对小兵（Soft）：小兵应让路（侧移），车不让
- 精英怪冲锋（强推）对小兵（Soft）：小兵被挤开
- 两个 Hard 相遇：双方都不被推开 → 触发“协商”：一方短暂停让（按优先级/随机打破对称），否则就局部绕行

这能避免 Hard-Hard 永久对顶。

---

## 7) 一个具体场景示例（符合你设定）
- 30 个小兵（Soft）围成一团，2 个重甲兵（Hard）在团里移动
- 角色 A（同类 Character）要穿过去：
  1) 全局路径仍指向目标（不管人群）
  2) 局部代价评估发现：走廊里 Soft 很多但 Hard 只有 1 个且正在离开 → 进入 Push-Through
  3) A 推开 Soft 形成通道；Soft 通过弹簧回位
  4) 若 Hard 恰好挡住且不离开，A 速度下降触发卡住检测 → 切换局部绕行，选一个侧向中间点绕过 Hard，再继续推开 Soft

Hard 从头到尾都没被当成“不可达墙”，但也不会被推开。

---

## 你接下来要做实现时，我建议你先回答一个关键选择
你希望 A 的“绕行”是：
1) **只在局部 steering 层绕**（不改 MoveTo 目标，靠局部偏置绕过去），还是  
2) **会临时改 MoveTo 到中间点**（我上面说的局部重规划）？

两者都能做，但 2) 更稳定、可控、也更容易调参（尤其是 Hard 密度高时）。你确认后我可以把“代价函数、采样方式、卡住检测阈值、以及中间点选择”给到更具体的参数级方案。

## 来自你的消息
由于角色的体型不一样，有些路口小角色能过，大角色不能通过，但是不能设置生成导航网格的宽度是大角色的宽度，因为小角色还是需要通过那些狭小入口的，这个问题应该如何解决呢？
<environment_details>
# Current Time
1/27/2026, 1:46:43 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
这个问题在 UE/Recast 里属于典型的“**不同体型需要不同可通行空间**”。核心结论是：**不要试图用一张 NavMesh 同时精确表达所有体型**；正确做法是用**多 NavData（多套 NavMesh）或在同一 NavMesh 上做“窄通道标记 + 过滤/约束”**，再配合**动态重规划/门洞规则**。

下面给你几种工程上最常用、可组合的方案（按推荐度排序），并说明适用场景。

---

## 方案 1（最推荐）：多套 NavMesh（不同 Agent 半径/高度）
**思路**：为“小/中/大”体型分别生成 NavMesh。小角色用小半径的 NavData，大角色用大半径的 NavData。这样狭窄入口只会出现在“小 NavMesh”里，大角色根本不会把它当可走。

**UE 里怎么做（概念）**
- 在 `Project Settings -> Navigation System` 里配置多个 **Supported Agents**（不同 `Radius/Height/StepHeight`）。
- 场景里会生成对应的多个 `RecastNavMesh`（每个 agent 一套）。
- 每个 AI 的 `NavAgentProperties` 选择匹配的 agent（通常在 `CharacterMovementComponent` 或 Pawn 的 nav agent 设置里）。

**优点**
- 语义最正确：大角色不会规划到它过不去的门。
- 不需要运行时做复杂碰撞检测来“纠错”。

**代价**
- 内存/构建时间增加（多一套 NavMesh 就多一份 tile 数据）。
- 需要确保 AIController/MoveTo 使用正确的 NavData。

**实际用例**
- 地牢里有“狗洞/通风管”：小怪能钻，大怪/Boss 不能。用两套 NavMesh 最省心。

---

## 方案 2：单 NavMesh + “窄通道区域标记” + Query Filter（次推荐）
**思路**：仍只生成一张偏“小体型”的 NavMesh（保证小角色能走），但把“狭窄入口/窄走廊”标成特殊 Area（例如 `NavArea_Narrow`）。大角色的寻路过滤器把该 Area 设为**不可通过**或**极高代价**，从而避免规划进去。

**关键点**
- 你需要一种方式把“窄”识别出来并标记成 Area：
  - 最常见：在窄门处放 `NavModifierVolume` 标记为 `NavArea_Narrow`。
  - 或者用自定义生成规则/离线分析（复杂，不建议一开始就做）。

**优点**
- 只维护一张 NavMesh，成本低。
- 设计师可控：哪里算窄由关卡标记。

**缺点**
- 标记需要维护；如果关卡变化大，容易漏标。
- “窄”是离散标记，不如多 NavMesh 精确（比如某些地方其实对中体型可过，对大体型不可过）。

**实际用例**
- 城市场景：小巷允许小兵穿行，重甲单位不进小巷。用 `NavArea_Narrow` + 大单位过滤器即可。

---

## 方案 3：单 NavMesh（小体型）+ 运行时“通行性验证/纠错”（兜底）
**思路**：允许大角色先按小 NavMesh 规划，但在执行路径时对关键瓶颈（门洞、拐角）做**几何验证**：用大角色的胶囊在路径走廊上做 sweep/trace，发现过不去就触发局部重规划/换路/换行为（例如请求开门、破坏、等待）。

**优点**
- 不需要多 NavMesh，也不需要关卡大量标记。
- 对动态变化（临时堆物、可破坏）更鲁棒。

**缺点**
- 这是“事后纠错”，会出现走到门口才发现过不去的情况，需要良好的 fallback（绕行/等待/换目标）。
- 实现复杂度更高，调试成本更大。

**实际用例**
- 物理可破坏/动态摆放障碍的游戏：NavMesh 很难实时精确反映所有狭窄变化，只能靠运行时 sweep 验证。

---

## 方案 4：门洞/狭窄处做“Smart Object / 通行规则”（与上面方案叠加）
**思路**：把狭窄入口当作“可交互通道”，进入需要申请 token、对齐姿态、甚至切换动画（侧身、蹲下）。大角色申请失败就不会走这条路。

**优点**
- 行为表现最好（过门、侧身、排队）。
- 适合“窄入口本身就是玩法点”的情况。

**缺点**
- 需要额外系统支持（占用、排队、动画对齐）。

**实际用例**
- 潜行游戏通风管：小角色进入播放爬行动画；大角色根本不能进入。

---

## 我给你的推荐组合（最稳的工程解）
- **如果体型差异明显（小兵 vs 巨人/Boss）**：优先用 **方案 1：多套 NavMesh**。  
- **如果只是少量“特殊窄入口”**：用 **方案 2：窄通道 Area + Filter**，最省资源。  
- 无论哪种，都建议加一个 **方案 3 的 sweep 兜底**，防止关卡漏标或动态障碍导致“理论可走但实际卡住”。

---

## 需要你确认两点，我才能给你更精确的落地建议
1) 你现在的“体型差异”大概是几档？（例如半径 34/60/120 这种量级）  
2) 狭窄入口是**少量手工设计的门洞**，还是**大量自然形成的小巷/碎石通道**？

你回这两点后，我可以按你的情况给出：应该配几套 agent、每套的半径/高度如何选、以及窄通道用 Area 标记时的维护策略。

## 来自你的消息
使用 窄通道区域标记 方法是不合理的，由于场景较多，场景较大，手动布置标记是非常费时费力的做法，能否在计算时携带角色的信息 比如身高、宽度等信息，在寻路时对路径进行宽度校验？
<environment_details>
# Current Time
1/27/2026, 10:02:33 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
可以，但要先把预期说清楚：**“在寻路时携带角色宽度/身高，并对路径做宽度校验”**在 Recast/Detour 体系里不是一个“免费开关”，因为 **NavMesh 的可通行性本质上已经把 agent 半径/高度烘焙进去了**。  
所以你想要的“同一张 NavMesh，查询时再按不同体型过滤窄通道”，通常有两条可落地路线：

1) **仍然生成多套 NavMesh（自动、无需手工标记）** ——这是 Recast 的正统解法，最稳。  
2) **单 NavMesh + 运行时几何校验/走廊校验（sweep/clearance）** ——可以做到“查询时携带体型”，但它是“事后验证 + 局部修正”，不是纯粹的 A* 过滤。

你明确说不想手工标记，我下面重点讲 **路线 2**（你问的“宽度校验”），同时也会说明为什么很多项目最后还是会回到路线 1。

---

## 路线 2：寻路后做“路径走廊宽度校验”，不通过则局部重规划

### 核心思想
- 先用现有 NavMesh（通常按“小体型”生成）得到一条路径（poly corridor / path points）。
- 然后用角色的 **胶囊体（半径/高度）** 对这条路径做 **可通行性验证**：
  - 验证通过：照常走。
  - 验证失败：在失败点附近做 **局部绕行**（找替代中间点/换走廊），或直接触发“换策略”（等待、破坏、开门、换目标）。

这满足你要的：**计算时携带角色信息**，并且不需要关卡手工标记。

---

## 1) 宽度校验怎么做（两种强度）

### A. 便宜版：沿路径点做 Capsule Sweep（推荐先做这个）
对路径点序列（或每段线段）做胶囊 sweep：

- 对每一段 \([P_k, P_{k+1}]\)：
  - 用角色胶囊（半径 = 角色半径，半高 = 角色半高）做 `SweepSingleByChannel` 或 `SweepMultiByChannel`
  - 碰到静态几何（墙、柱子）则判定该段不可通行
- 采样步长建议 30–80cm（取决于场景尺度），或直接对线段 sweep（更省）

**优点**
- 实现简单，完全运行时，适配任意几何。
- 不依赖 NavMesh 内部细节。

**缺点**
- 只验证“几何是否能过”，不直接告诉你“哪里窄、窄多少”，也不直接给替代路径。

### B. 精确版：对 NavMesh 走廊做 Clearance/通行余量估计（更复杂）
如果你愿意深入 Detour，可以对路径走廊的多边形边界估算“到边界的最小距离”（clearance），判断是否 \(\ge\) 角色半径。  
但 UE 默认并没有直接暴露一个“每个 poly 的 clearance 场”给你用；你要么：
- 自己在构建后离线计算并存储 clearance（成本高），要么
- 运行时对走廊边界做最近距离查询（也不便宜）

所以工程上更常见的是 **A（sweep）+ 局部重规划**。

---

## 2) 校验失败后怎么“自动绕开窄口”（关键）
你不想手工标记，那就必须有一个自动 fallback。常用做法是：

### 局部重规划到中间点（Local Reroute）
当在第 \(k\) 段发现不可通行：
1. 取失败点附近一个“重规划中心” \(C\)（比如 \(P_k\) 或碰撞点）
2. 在 \(C\) 周围的扇形/圆环上采样候选点 \(c_i\)（半径 2–8m，角度覆盖前方）
3. 对每个 \(c_i\)：
   - 投影到 NavMesh（保证是可走点）
   - 计算 `Path(A -> c_i)` + `Path(c_i -> Goal)`（可以只算到原路径后方某个点以省）
   - 对新路径再做一次快速 sweep 校验（只校验前几米即可）
4. 选一个“最短且可通过”的 \(c^*\)，临时 `MoveTo(c^*)`，到达后再 `MoveTo(Goal)`

这相当于你在运行时“自动找绕开窄口的入口”，不需要任何手工标记。

---

## 3) 性能怎么控（否则你会把寻路省下来的又花在 sweep 上）
你担心大场景、多角色，这个方案必须做预算：

- **只对“大体型”做校验**：小体型直接走。
- **只校验前方一小段**：例如只校验未来 3–6 秒的路程（或前 10–20m），而不是整条路径。
- **低频校验**：0.2–0.5s 校验一次，或“路径更新/转角处”才校验。
- **失败才加密**：平时粗采样，检测到风险再细采样。
- **分帧预算**：每帧最多做 N 次 sweep/局部重规划，其余排队。

---

## 4) 这个方案的边界与风险（你需要接受的现实）
- 它是“**先规划、后验证、再修正**”，所以可能出现：大角色走到窄门口才发现过不去，然后再绕行。你可以通过“前方走廊提前校验”把这种情况提前到更早发生，但无法完全消除。
- 如果场景里“窄口”非常多且分布复杂，最终你会发现：**多 NavMesh 其实更省 CPU**（因为它从源头避免生成错误路径）。

---

## 5) 仍然要强调：多 NavMesh 并不等于手工标记
你反对的是“手工布置窄通道标记”，但**多套 NavMesh 是自动生成**，不需要你在大地图里一个个放体积标记。  
如果你有明显的体型档位（小/大），多 NavMesh 往往是最省心的“自动宽度校验”。

---

## 给你一个可执行的落地建议（不改引擎也能做）
1. NavMesh 按“小体型”生成，保证覆盖所有狭窄通道。  
2. 大体型单位：
   - 拿到路径后，**只校验前 10–20m** 的路径段（capsule sweep）。
   - 失败则触发“局部重规划到中间点”。
3. 加“卡住检测”（速度低于阈值持续 \(t\) 秒）作为兜底，再触发一次局部重规划/换策略。

---

## 我可以进一步给你 UE 级别的实现细节，但需要你确认两点
1) 你们的大体型是 **Character 胶囊**还是自定义碰撞？（半径/半高是否稳定）  
2) 你们的障碍主要是 **静态几何（墙体）**，还是有大量 **动态可移动物/角色** 也会造成窄口？

你确认后，我可以把“路径段 sweep 的触发时机、采样步长、局部重规划的候选点生成与评分函数”给成一套更具体的参数与流程。

## 来自你的消息
游戏中，我们的角色有很多移动方式，跳跃、飞行等，比如玩家可以从一楼跳跃到二楼，也可以从二楼跳跃到一楼
我的问题是
1. 针对二楼跳到一楼的情况，如果单纯用 LinkProxy 来规划路径，所有AI都会固定的从那么几个 LinkProxy 来规划路径，然后从二楼跳跃到一楼，原本很宽敞的二楼阳台，却偏偏在那么几个 LinkProxy 上排队
2. 针对一楼跳到二楼的情况，同理，如果使用 Linkproxy 首先布置起来非常麻烦，因而类似的高低差随处可见，其次会出现寻路到相同的 LinkProxy 导致排队的情况
<environment_details>
# Current Time
1/27/2026, 10:12:34 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
你遇到的是“**离散 LinkProxy 把连续可跳区域离散化**”带来的两个必然后果：  
- AI 只能走到少数几个入口 → **汇聚/排队**  
- 大地图高低差多 → **手工布置不可扩展**

要解决它，思路是把“跳跃/飞行”从“少数固定链接点”升级为两层系统：

1) **自动生成大量可用的 Off-mesh 连接（或可跳边）**：让可跳区域是“连续的”，而不是几个点。  
2) **在寻路时做“连接点选择/分配”**：即使有很多连接，也要避免所有人选同一个（拥挤感知 + slot/预约）。

下面给你一套 UE 中常见、可落地的方案组合，分别覆盖“二楼→一楼（下跳）”和“一楼→二楼（上跳）”。

---

## 总体方案：把 LinkProxy 变成“自动化的 Jump Links + 拥挤感知选择”
### 关键组件（概念）
- **Jump Link 生成器**：离线/运行时扫描边缘，自动生成可跳连接（不手工摆）
- **Jump Link 选择器**：同一对楼层有很多可跳点时，按代价+拥挤选择
- **Jump Link 预约/slot**：避免同一时刻大量 AI 选同一条 link

---

## 1) 二楼跳到一楼：不要只在几个点下跳，而是“沿阳台边缘任意点都可下跳”
### 1.1 自动生成“下跳边缘 links”（Edge-based links）
**思路**：二楼阳台边缘是一条长边，理论上很多位置都能下跳。你应该把这条边缘离散采样成很多 off-mesh links（每隔 1–2m 一个），而不是手工放 2–3 个 LinkProxy。

**怎么自动找“可下跳边缘”**
- 在 NavMesh 上找“边界边”（nav poly 的外边界）
- 对边界边做采样点 \(p_i\)
- 对每个 \(p_i\)：
  - 向外/向下做射线，找到落点地面 \(q_i\)
  - 检查高度差在可下跳范围（例如 1m–4m）
  - 检查落点附近有足够站立空间（胶囊 sweep）
  - 检查下落轨迹无遮挡（可选）
- 通过则生成一条 link：`p_i (2F) -> q_i (1F)`，类型标记为 `DropDown`

**效果**
- AI 会在整条阳台边缘“分散下跳”，不会挤在几个 LinkProxy 排队。

**实际用例**
- 许多潜行/射击游戏的阳台下跳：NPC 会在靠近自己位置的边缘直接翻下去，而不是跑到固定梯口。

### 1.2 连接点选择加入“拥挤代价”
即使你生成了很多 links，也可能出现“大家都选最近的那一个”。解决方法是在寻路代价里加入：
- link 入口附近的**局部密度/排队长度**
- link 的**预约人数**

代价示意：
\[
Cost = DistToLink + LinkTraversalCost + \alpha \cdot CrowdDensity + \beta \cdot ReservedCount
\]
这样 AI 会自然分流到不同下跳点。

### 1.3 预约/slot（避免同一帧冲同一点）
对每条 link 维护一个小容量（例如同时允许 1–2 个进入），其余在附近等待点（或直接选别的 link）。  
这比“门口排队”更像“人群分散找位置下去”。

---

## 2) 一楼跳到二楼：上跳更苛刻，需要“可达性/落点”验证 + 自动生成
上跳比下跳难，因为需要：
- 起跳点空间
- 抛物线/攀爬轨迹可行
- 二楼落点可站立且可接回 NavMesh

### 2.1 自动生成“上跳候选点对”（Ground-to-Ledge links）
**思路**：不要摆 LinkProxy；扫描一楼可行走区域，找二楼可落点的“ledge（边缘）”，自动生成 `JumpUp` links。

**生成方法（可离线烘焙，也可运行时分块生成）**
- 找二楼 NavMesh 的边界边（ledge）
- 沿 ledge 采样落点 \(L_i\)（每隔 1–2m）
- 对每个 \(L_i\)：
  - 在其外侧/下方搜索可能的起跳点 \(S_{i,k}\)（例如在一楼 NavMesh 上投影一个区域）
  - 对每个 \(S_{i,k}\) 做“跳跃可行性测试”：
    - 简化版：几何高度差 + 水平距离在阈值内
    - 精确版：按角色跳跃参数模拟抛物线并做多段 sweep（检查中途不撞墙）
  - 通过则生成 link：`S -> L`，类型 `JumpUp`

**效果**
- 高低差随处可见也不怕：生成器会自动覆盖。
- AI 不会都跑到同一个“梯口 link”，因为 ledge 上有很多可上跳点。

### 2.2 同样加入“拥挤代价 + 预约”
上跳点通常更少、更容易拥挤，所以更需要：
- 入口密度代价
- 预约容量（一次只允许少数角色起跳，避免互相撞）

---

## 3) 你可能会问：UE 现成系统能做到多少？
- **NavLinkProxy**：适合少量、手工、语义明确的连接（梯子、门、固定跳点）。不适合你这种“到处都是高低差”的规模。
- **SmartNavLink / Off-mesh links**：更适合自动生成大量连接，并在运行时启用/禁用。
- **MassAI / Crowd**：解决“走廊内避障”，但对“大家都去同一个 link”帮助有限，必须配合“连接点选择/分配”。

所以你的问题不是“要不要 LinkProxy”，而是：**LinkProxy 的粒度太粗**。你需要“自动化 + 高密度 links + 拥挤感知”。

---

## 4) 最小可落地的实施路线（建议你按这个顺序做）
1. **先做下跳（DropDown）自动 links**：最容易，收益立竿见影（阳台不排队）。  
2. 给 link 加 **拥挤代价**（基于入口 overlap 的人数 + 预约数）。  
3. 再做上跳（JumpUp）自动 links：先用简化可行性（距离/高度阈值），跑通后再加抛物线 sweep 精确化。  
4. 最后把“跳跃执行”做成统一的 `Traversal Action`（播放动画/RootMotion/物理跳），并在动作期间锁定 link 预约。

---

## 我需要你给我 3 个信息，我就能把方案进一步落到“UE 具体实现点/数据结构/参数”
1) 你们的跳跃是 **物理 Character Jump**，还是 **RootMotion/蒙太奇位移**，还是两者都有？  
2) 你们的关卡是 **静态烘焙 NavMesh** 为主，还是有大量动态生成/破坏？  
3) 你们希望 AI 的跳跃是“任何边缘都能跳”（偏系统化），还是“只允许设计师认可的边缘”（偏可控）？

你回这三点后，我可以给你一套更具体的：采样间距、可行性测试（简化/精确）、拥挤代价计算、以及预约/排队的状态机设计。

## 来自你的消息
在一次 MoveTo 的时候，是自动选择 LinkProxy 的，如何实现不使用正在排队的 LinkProxy？
<environment_details>
# Current Time
1/27/2026, 10:19:03 AM (Asia/Shanghai, UTC+8:00)
</environment_details>


## 来自 CodeMaker 的消息
要做到“`MoveTo` 自动选 LinkProxy，但**不要选正在排队的那个**”，核心是把“排队/拥挤”变成**寻路代价的一部分**，让 Detour 在算路时自然避开这些 link；或者在路径生成后**检测到会走到拥挤 link 就触发重规划**。UE 里最稳的是第一种：**自定义 `UNavigationQueryFilter` + 自定义 Area/Link 代价**。

下面给你两条可落地路线（推荐先做 A，再加 B 兜底）。

---

## A) 在寻路阶段避开：给“正在排队的 Link”动态加高代价（或直接禁用）
### A1. 最简单：拥挤时临时禁用该 Link（硬避开）
**做法**
- 每个 `NavLinkProxy` 维护一个“排队人数/预约数”。
- 当 `QueueCount >= Capacity`：
  - 把该 link 设为不可用（禁用 SmartLink，或让 link 不参与寻路）
- 当队列下降：再启用。

**优点**
- 实现快，效果直接：不会再规划到这个 link。
**缺点**
- 过于“硬”，可能导致绕路很远；并且如果所有 link 都满了，会出现无路可走（需要 fallback：等待）。

> 适合：link 数量多、替代 link 很近的场景（比如一排阳台下跳点）。

### A2. 更自然：拥挤时提高该 Link 的 traversal cost（软避开）
**做法**
- 给 link 对应的 area（或 link traversal）一个动态 cost：  
  \[
  Cost = BaseCost + \alpha \cdot QueueCount
  \]
- 在 `MoveTo` 时使用自定义 `FilterClass`（`FAIMoveRequest::SetNavigationFilter`），让寻路使用你的 cost 规则。
- 这样：不拥挤的 link 更便宜 → 自动分流；只有当其它路更差时才会选择拥挤 link。

**优点**
- 分流自然，不会突然“无路可走”。
**缺点**
- 需要你能把“link 的排队状态”映射到 Detour 可用的 cost 上（UE 默认对 link 的动态 cost 支持有限，通常要通过 area/filter 或自定义路径代价逻辑实现）。

---

## B) 在执行阶段兜底：发现路径将进入“排队 link”就重规划/换目标
因为 UE 的 `MoveTo` 是一次性算出路径，执行过程中 link 的排队状态可能变化，所以需要兜底：

**做法**
1. `OnPathUpdated` / `OnMoveFinished` / 或 PathFollowing tick 中检查“下一条即将使用的 link”
2. 如果该 link 当前 `QueueCount >= Capacity`：
   - 取消当前 Move（或请求重算路径）
   - 重新发起 `MoveTo`（同目标，但带上“避开该 link”的临时过滤条件）
   - 或者直接改为 `MoveTo` 一个“替代入口点”（你自己选一个不拥挤的 link 入口点作为中间目标）

**优点**
- 不依赖引擎对 link cost 的支持程度，工程上很好落地。
**缺点**
- 可能出现“走到门口才改道”的抖动，需要加冷却时间/滞回。

---

## 推荐的工程组合（最常用）
1. **link 预约容量**：每条 link 同时允许进入的人数（1–2 个）  
2. **超过容量：软避开（加 cost）**；如果你做不了动态 cost，就先用 **硬禁用**  
3. **执行阶段兜底重规划**：避免路径算完后队列变化导致仍然挤过去

---

## 关键实现点（你需要做的“排队”数据）
无论 A 还是 B，你都需要每条 link 有：
- `Capacity`
- `ReservedCount`（已预约但未开始 traversing）
- `QueueCount`（在入口等待区的人数，可选）
- `IsAvailable()`：`ReservedCount < Capacity`

并且在 AI 即将进入 link 前：
- 先 `TryReserve()`，成功才允许继续；失败就触发重规划/换 link。

这能保证“不会所有人同时冲向同一个 link”。

---

## 我需要你确认一个细节，才能告诉你在 UE 里最合适的挂点
你用的是：
1) `NavLinkProxy` 的 **SmartLink**（`bSmartLinkIsRelevant`，走 `ReceiveSmartLinkReached` 那套），还是  
2) 普通的 point-to-point link（非 smart）？

如果是 **SmartLink**，实现“预约/拒绝进入”会非常顺（在到达 link 时决定是否放行）。  
如果是普通 link，更适合用“执行阶段兜底重规划”或直接改成 SmartLink。
