<!--
 * @Author: your name
 * @Date: 2021-10-01 11:33:27
 * @LastEditTime: 2022-02-20 21:15:21
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: D:\MarkdownLog\图形学.md

https://latex.codecogs.com/svg.latex?\vec{A}=(^{x}_{y})\\\vec{A}^T=(x,y)\\\lVert\vec{A}=\sqrt{x^2+y^2}\rVert\

-->

为什么要学习计算机图形学？——计算机图形学就是厉害

> 图形学是非常广阔的世界

# 前提知识

- 基础数学
- 基础物理
- 信号处理
- 数值分析
- 美学
- ……

## 线性代数

向量、矩阵的操作，点乘、叉乘、矩阵乘法等  

### 点乘

$$
\vec{A} = (^{x} _{y}) \\
\vec{A}^T = (x, y) \\
\lVert \vec{A} = \sqrt{x ^2 + y^2} \rVert \\
$$

向量之间的点乘 

$$
\vec{A} \cdot \vec{B} = \lVert \vec{A} \rVert * \lVert \vec{B} \rVert * \cos \theta \\
\cos \Theta = \frac{\vec{A} \cdot \vec{B}}{\lVert \vec{A} \rVert * \lVert \vec{B} \rVert}
$$

向量点乘的数学运算规则

1. 交换律：$\vec{a} \cdot \vec{b} = \vec{b} \cdot \vec{a}$
2. 分配律：$\vec{a} \cdot (\vec{b} + \vec{c}) = \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}$
3. 结合律：$(k*\vec{a}) \cdot \vec{b} = \vec{a} \cdot (\vec{b} * k) = k * (\vec{a} \cdot \vec{b})$

点乘的运算

- 2D： $\vec{a} \cdot \vec{b} = (^{x_a} _{y_a}) \cdot (^{x_b} _{y_b}) = x_a*x_b + y_a*y_b $
- 3D： $\vec{a} \cdot \vec{b} = \begin{pmatrix}x_a \\ y_a \\ z_a\end{pmatrix} \cdot \begin{pmatrix} x_b \\ y_b \\ y_c \end{pmatrix} = x_a * x_b + y_a * y_b + z_a * z_b$

![](./Image/1.png)

$$
\vec{b_{\bot}} = \lVert \vec{b_\bot} \rVert = \lVert \vec{b} \rVert * \cos \Theta
$$

![](./Image/2.png)

> 方向大致相同：$\cos{(\vec{a} \backsim \vec{b})} < 0$  
> 方向不同：$\cos{(\vec{a} \backsim \vec{c})} > 0$  

- 向量点乘的作用(单位向量)
  - 通过点乘的运算，可以找到两个方向之间的余弦夹角  
  - 找到一个向量投影到另一个向量中，也会用到点乘运算  
  - 判断两个向量是否接近，通过值的大小比较即可（cos在0~$\pi$单调递减）
  - 关于是否同方向的信息（$\cos \theta$小于$90°$大于0，否则小于0）

### 叉乘

两个向量叉乘的结果是垂直于当前两个向量所在平面的新的向量  

![](./Image/3.png)

$$
\vec{a} \times \vec{b} = -\vec{b} \times \vec{a}\\
\lVert \vec{a} \times \vec{b} \rVert = \lVert \vec{a} \rVert * \lVert \vec{b} \rVert * \sin{\Theta}
$$

叉乘的运算需要用到右手螺旋法则，$\vec{a} \times \vec{b}$就是四指从$\vec{a}$到$\vec{b}$，那么大拇指的指向就是$\vec{c}$所在的方向

叉乘的一些数学运算规律  

- 叉乘没有交换律
- 叉乘有分配律
- 叉乘有结合律

$$
\vec{x} \times \vec{y} = + \vec{z}\\
\vec{y} \times \vec{x} = - \vec{z}\\
\vec{y} \times \vec{z} = + \vec{x}\\
\vec{z} \times \vec{y} = - \vec{x}\\
\vec{z} \times \vec{x} = + \vec{y}\\
\vec{z} \times \vec{x} = - \vec{y}\\
\vec{a} \times \vec{b} = -\vec{b} \times \vec{a}\\
\vec{a} \times \vec{a} = \vec{0}\\
\vec{a} \times (\vec{b} + \vec{c}) = \vec{a} \times \vec{b} + \vec{a} \times \vec{c}\\
\vec{a} \times (k * \vec{b}) = k * (\vec{a} \times \vec{b})\\
$$

> 上述所有都基于右手坐标系  
> 叉乘没有交换律  

叉乘的数学计算方式

$$
\vec{a} \times \vec{b} = 
\begin{pmatrix}
    y_a * z_b - y_b * z_a \\
    z_a * x_b - x_a * z_b \\
    x_a * y_b - y_a * x_b \\
\end{pmatrix}
$$

- 叉乘的作用
  - 判断左右(根据右手螺旋法则)
  - 判断内外(点是否在三角形内的叉乘解法)

## 矩阵

矩阵和一个数相乘

$$
k * 
\begin{pmatrix}
    x & a \\ 
    y & b \\
    z & c \\
\end{pmatrix} = 
\begin{pmatrix}
    k*x & k*a \\ 
    k*y & k*b \\
    k*z & k*c \\
\end{pmatrix}
$$

矩阵和一个矩阵相乘  

**A矩阵的列数必须等于B矩阵的行数**

$\left( M \times N \right) * \left( N \times P \right) = \left( M \times N \right)$公式中$\left( M \times N \right)$表示M行、N列的矩阵

$$
\begin{pmatrix}
    x_1 & a_1 \\ 
    y_1 & b_1 \\
    z_1 & c_1 \\
\end{pmatrix}*
\begin{pmatrix}
    x_2 & a_2 & q_2 & e_2 \\ 
    y_2 & b_2 & w_2 & r_2 \\
\end{pmatrix}=
\begin{pmatrix}
    x_1 * x_2 + a_1 * y_2 & x_1 * a_2 + a_1 * b_2 & x_1 * q_2 + a_1 * w_2 & x_1 * e_2 + a_1 * r_2 \\ 
    y_1 * x_2 + b_1 * y_2 & y_1 * a_2 + b_1 * b_2 & y_1 * q_2 + b_1 * w_2 & y_1 * e_2 + b_1 * r_2 +\\
    z_1 * x_2 + c_1 * y_2 & z_1 * a_2 + c_1 * b_2 & z_1 * q_2 + c_1 * w_2 & z_1 * e_2 + c_1 * r_2 \\
\end{pmatrix}
$$

- 矩阵的数学规律
  - 矩阵**没有交换律**
  - 矩阵有结合律$(AB)C = A(BC)$
  - 矩阵具有分配律$A(B+C) = AB + AC$

当矩阵与向量相乘时，一般将矩阵放在左边，向量放在右边，向量可以看作是(M, 1)的矩阵，那么左边的矩阵只要是M列就行  

将单位向量按y轴对称的操作：
$$
\begin{bmatrix}
    -1 & 0 \\
    0 & 1
\end{bmatrix} *
\begin{bmatrix}
    x\\
    y
\end{bmatrix}=
\begin{bmatrix}
    -x \\
    y
\end{bmatrix}
$$

矩阵的转置:行和列互换

$$
\begin{bmatrix}
    1 & 2 \\
    3 & 4 \\
    5 & 6 
\end{bmatrix} ^T = 
\begin{bmatrix}
    1 & 3 & 5 \\
    2 & 4 & 6 
\end{bmatrix}
\\
(AB)^T = B^T * A^T
$$

单位矩阵:主对角线上是1，其他地方都是0

$$
I_{3\times3} = 
\begin{bmatrix}
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1
\end{bmatrix}
$$

矩阵的逆：矩阵A乘矩阵B得到单位矩阵，则成B是A的逆，写作$A^{-1}$

$AA^{-1} = I$、$(AB)^{-1} = B^{-1} * A^{-1}$

向量的点乘转成矩阵运算

$$
\vec{a} \cdot \vec{b} = \vec{a}^T\vec{b}=
\begin{bmatrix}
    x_a & y_a & z_a
\end{bmatrix} 
\begin{bmatrix}
    x_b \\ y_b \\ z_b
\end{bmatrix}= \left( x_a*x_b + y_a*y_b + z_a*z_b \right)
$$

向量的叉乘转成矩阵运算

$$
\vec{a} \times \vec{b} = A^*\vec{b} = 
\begin{bmatrix}
    0 & -z_a & y_a \\
    z_a & 0 & -x_a \\
    -y_a & x_a & 0
\end{bmatrix}
\begin{bmatrix}
    x_b \\ y_b \\ z_b
\end{bmatrix}
$$

> $A^*$是$\vec{a}$的dual matrix

## 变换

### 仿射变换

#### 伸缩变换(Scale)

![缩放](./Image/4.png)

$$
x^` = sx\\
y^` = sy\\
\Rightarrow \\
\begin{bmatrix}
    x^` \\ y^`
\end{bmatrix}= 
\begin{bmatrix}
    s & 0 \\
    0 & s 
\end{bmatrix}
\begin{bmatrix}
    x \\ y
\end{bmatrix}
$$

### 镜像

![缩放](./Image/5.png)

$$
x^` = -x\\
y^` = y\\
\Rightarrow \\
\begin{bmatrix}
    x^` \\ y^`
\end{bmatrix}= 
\begin{bmatrix}
    -1 & 0 \\
    0 & 1 
\end{bmatrix}
\begin{bmatrix}
    x \\ y
\end{bmatrix}
$$

#### 切变

![切变](./Image/6.png)

$$
x^` = x + a*y\\
y^` = y\\
\Rightarrow \\
\begin{bmatrix}
    x^` \\ y^`
\end{bmatrix}= 
\begin{bmatrix}
    1 & a \\
    0 & 1 
\end{bmatrix}
\begin{bmatrix}
    x \\ y 
\end{bmatrix}
$$

#### 旋转(Rotate)

**默认绕原点逆时针旋转**

![旋转](./Image/7.png)

公式推导  
- 右下角点坐标(1, 0)=>($\cos\Theta, \sin\Theta$)
- 左上角点坐标(0, 1)=>($-\sin\Theta, \cos\Theta$)

$$
\left(x^`, y^`\right)
\Longrightarrow
\begin{bmatrix}
    A & B \\
    C & D 
\end{bmatrix}
\begin{bmatrix}
    x \\ y
\end{bmatrix}\\
带入x=1, y=0, x^`=\cos\Theta, y^`=\sin\Theta\\
得: A = \cos\Theta , C = \sin\Theta\\
带入x=0, y=1, x^`=-\sin\Theta, y^`=\cos\Theta\\
得: B = -\sin\Theta, D = \cos\Theta
$$

#### 平移(Transiation)

![平移](./Image/8.png)

- $x^` = x + t_x$
- $y^` = y + t_y$

$$
\begin{bmatrix}
    x^` \\ y ^ `
\end{bmatrix}=
\begin{bmatrix}
    1 & 0 \\
    0 & 1 
\end{bmatrix}
\begin{bmatrix}
    x \\ y
\end{bmatrix}+
\begin{bmatrix}
    t_x \\ t_y
\end{bmatrix}
$$

很明显，这个**平移**的坐标无法通过一个矩阵就表示出来，这个时候就需要引入**齐次矩阵**

> **齐次矩阵**就是将一个原本是n维的向量用一个n+1维向量来表示

$$
\begin{bmatrix}
    x^` \\ y ^ ` \\ 1
\end{bmatrix}=
\begin{bmatrix}
    1 & 0 & t_x \\
    0 & 1 & t_y \\
    0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
    x \\ y \\ 1
\end{bmatrix}=
\begin{bmatrix}
    x + t_x \\ y + t_y \\ 1
\end{bmatrix}
$$

通过齐次坐标矩阵就可以使用一个矩阵来表示线性变换，**为了保证变换矩阵的一致性**，所以上面讲的**所有矩阵都需要转换成齐次矩阵**

在其次坐标中，点使用$\begin{pmatrix}
    x \\ y \\ 1
\end{pmatrix}$
来表示，向量使用$\begin{pmatrix}
    x \\ y \\ 0
\end{pmatrix}$
来表示

- 向量 + 向量 = 向量  
- point - point = 向量
- point + vector = point
- point + point = 两点的中点

为什么point + point的结果是两个点的中点

$$
A = \begin{pmatrix}
    x \\ y \\ w
\end{pmatrix}=
\begin{pmatrix}
    x / w \\ y / w \\ 1
\end{pmatrix}
\\
B = \begin{pmatrix}
    a \\ b \\ c
\end{pmatrix}=
\begin{pmatrix}
    a / c \\ b / c \\ 1
\end{pmatrix}
\\
A + B = 
\begin{pmatrix}
    x/w + a/c \\ y/w + b/c \\ 2
\end{pmatrix}=
\begin{pmatrix}
    \frac{x}{2w} + \frac{a}{2c} \\
    \frac{y}{2w} + \frac{b}{2c} \\
    1
\end{pmatrix}
$$

#### 总和

$$
Scale \Longrightarrow
S(s_x, s_y) = 
\begin{pmatrix}
    s_x & 0 & 0 \\
    0 & s_y & 0 \\
    0 & 0 & 1
\end{pmatrix}
\\
Rotation \Longrightarrow
R(\Theta) = 
\begin{pmatrix}
    \cos\Theta & -\sin\Theta & 0 \\
    \sin\Theta & \cos\Theta & 0 \\
    0 & 0 & 1
\end{pmatrix}
\\
Translation \Longrightarrow
T(t_x, t_y) = 
\begin{pmatrix}
    1 & 0 & t_x \\
    0 & 1 & t_y \\
    0 & 0 & 1
\end{pmatrix}
$$

### 逆变换

![逆变换](./Image/9.png)

逆变换就是把之前的操作反向来一次，对应的就是矩阵中的逆矩阵 



### 组合变换

- 图1
![图1](./Image/10.png)

- 图2
![图2](./Image/11.png)

> 旋转默认绕原点，逆时针旋转  

比较上述两张图片，可以发现先旋转再平移 与 先平移再旋转 得到的结果是不同的，对应的理解就是**矩阵的乘法**，矩阵乘法不满足交换律

为了得到图1的效果，我们需要先旋转45°，再向X轴正方向平移1一个单位

$$
T_{(1， 0)} \cdot R_{45} \cdot \begin{bmatrix}
    x \\ y \\ 1
\end{bmatrix}= 
\begin{bmatrix}
    1 & 0 & 1 \\
    0 & 1 & 0 \\
    0 & 0 & 1 
\end{bmatrix}
\begin{bmatrix}
    \cos45° & -\sin45° & 0 \\
    \sin45° & \cos45° & 0 \\
    0 & 0 & 1 
\end{bmatrix}
\begin{bmatrix}
    x \\ y \\ 1
\end{bmatrix}
$$

前面提过向量一般放在矩阵乘法的最右边，并且根据矩阵具有结合律，上述式子可以理解为先计算$R_{45}$与$\begin{bmatrix}x\\y\\1\end{bmatrix}$，再计算与$T_{(1, 0)}$的乘法

但是，根据矩阵的结合律，我们可以先把前面的矩阵的计算结果得出最终变换矩阵，最后与向量相乘

$$
A_n(...A_2(A_1(X)) = 
\underbrace{A_n...A_2 \cdot A_1}_{先计算} \cdot \begin{pmatrix}
    x \\ y \\ 1
\end{pmatrix}
$$

### 变换的分解

![变换的分解](./Image/12.png)

如果想让图片围绕左下角旋转，而不是原点选择，可以采用的解法是 

左下角移动到原点 => 绕原点旋转 => 左下角移动到起始位置  

### 三位空间的变换

三维与二维无非就是多了一个维度，其他的变换相似，原理相同

point : $\begin{pmatrix}
    x & y & z & 1
\end{pmatrix}^T$  
vector : $\begin{pmatrix}
    x & y & z & 0
\end{pmatrix}^T$

$$
\begin{pmatrix}
    x^` \\ y^1 \\ z^` \\ 1
\end{pmatrix}=
\begin{pmatrix}
    a & b & c & t_x \\
    d & e & f & t_y \\
    g & h & i & t_z \\
    0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
    x \\ y \\ z \\ 1
\end{pmatrix}
\\
Scale \Longrightarrow
S(s_x, s_y, s_z) =
\begin{pmatrix}
    s_x & 0 & 0 & 0 \\
    0 & s_y & 0 & 0 \\
    0 & 0 & s_z & 0 \\
    0 & 0 & 0 & 1
\end{pmatrix}
\\
Translation \Longrightarrow
T(t_x, t_y, t_z) =
\begin{pmatrix}
    1 & 0 & 0 & t_x \\
    0 & 1 & 0 & t_y \\
    0 & 0 & 1 & t_z \\
    0 & 0 & 0 & 1
\end{pmatrix}
\\
R_x(\Theta)=
\begin{pmatrix}
    1 & 0 & 0 & 0 \\
    0 & \cos\Theta & -\sin\Theta & 0 \\
    0 & \sin\Theta & \cos\Theta & 0 \\
    0 & 0 & 0 & 1
\end{pmatrix}绕X轴旋转
\\
R_y(\Theta) =
\begin{pmatrix}
    \cos\Theta & 0 & \sin\Theta & 0 \\
    0 & 1 & 0 & 0 \\
    -\sin\Theta & 0 & \cos\Theta & 0 \\
    0 & 0 & 0 & 1
\end{pmatrix}绕Y轴旋转
\\
R_z(\Theta) = 
\begin{pmatrix}
    \cos\Theta & -\sin\Theta & 0 & 0 \\
    \sin\Theta & \cos\Theta & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{pmatrix}绕Z轴旋转
\\
R_{xyz}(\alpha, \beta, \sigma) = R_x(\alpha)R_y(\beta)R_z(\sigma)
$$

> 旋转时，绕哪个轴旋转，那个轴对应的坐标不变，所以x轴旋转的第一行第一列、y轴旋转的第二行第二列、z轴旋转的第三行第三列

如何证明$R_{xyz}(\alpha, \beta, \sigma) = R_x(\alpha)R_y(\beta)R_z(\sigma)$成立，这个时候需要引入**罗德里格斯公式**


### 视图变换 Camera/View

视图就类似使用设计相机拍照，视图就是镜头中的世界  

- 拍一张好照片需要
  - 好的地方（Module），搭建场景
  - 好的角度（view），视图变换
  - 投影（三维空间投影到二维照片）

综上，就是图形学渲染出效果的模型(Model)、视图(View)、投影(Projection)变换，简称MVP变换

- 定义相机
  - 坐标
  - 向上的向量(一个向量就可以确定相机的Roll)
  - 朝向

![](./Image/13.png)

**约定：相机永远在原点，永远不动，永远以y轴向上，永远看向-Z轴**
其他物体也跟着相机移动

- 针对坐标为(x, y, z)，角度为(a, b, c)的相机，需要做哪些变换
  1. 相机移动到原点坐标
  2. 相机的朝向旋转到-Z轴方向
  3. 相机的向上向量旋转到Y轴方向

设定相机的朝向向量为g，相机向上的向量为t，可推得相机另一个轴的向量为$g \times t$

$$
T_{view} =
\begin{bmatrix}
    1 & 0 & 0 & -x_e \\
    0 & 1 & 0 & -y_e \\
    0 & 0 & 0 & -z_e
\end{bmatrix} 坐标变换矩阵
\\
R^{-1}_{view} =
\begin{bmatrix}
    x_{g \times t} & x_t & x_{-g} & 0 \\
    y_{g \times t} & y_t & y_{-g} & 0 \\
    z_{g \times t} & z_t & z_{-g} & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix} 不加证明给出矩阵R_{view}^{-1}
\\
R_{view}^{-1} * 
\begin{bmatrix}
    1 \\ 0 \\ 0
\end{bmatrix} = 
\begin{bmatrix}
    x_{g \times t} \\
    y_{g \times t} \\
    z_{g \times t} \\
\end{bmatrix} 可见R_{view}^{-1}乘以X轴、Y轴、Z轴都等于相机对应的向量坐标
\\
R^{-1}_{view} * 标准矩阵 = 相机矩阵 \Longrightarrow 相机矩阵 * R_{view} = 标准矩阵
\\
R_{view}^{-1}是R_{view}的逆矩阵
\\
R_{view} =
\begin{bmatrix}
    x_{g \times t} & y_{g \times t} &z_{g \times t} & 0 \\
    x_t & y_t & z_t & 0 \\
    x_{-g} & y_{-g} & z_{-g} & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix} 不加证明给出矩阵R_{view}
\\
M_{view} = R_{view} T_{view} 组合后得出视图变换矩阵(从右往左的理解顺序，先平移、再旋转)
$$

相机和所有的物体都根据该模型移动到特定位置，此时相机肯定是在原点的、看向-Z轴，向上坐标为Y轴的，各个物体的相对位置不变  

模型(单独对模型的操作)-视图(对相机的操作并同步到模型上)变换

### 投影变换

![](./Image/14.png)

> 图中左边为正交投影，右边是透视投影

- 正交投影不会带来近大远小的世界效果，一般用于工程制图  
- 透视投影会有近大远小

![](./Image/15.png)

> 图中左边为透视投影，右边为正交投影

对于正交投影出来的图片结果，可以理解为相机在一个无限远的地方拍照，这样物体之间的距离差距就可以忽略不计了(走路月亮跟着你走的也是这个原因)

#### 正交投影 Orthographic

![](./Image/16.png)

- 在正交投影中定义一个矩阵，需要定义
  - l(left)、r(right)，左平面距离矩形中心的距离和右平面距离矩形中心的距离
  - t(top)、b(bottom)，上平面距离矩形中心的距离和下平面距离矩形中心的距离
  - f(far)、r(near)，远平面距离矩形中心的距离和近平面距离矩形中心的距离

> 因为相机朝向是-Z轴，所以f值一般小于r值

在定义完一个矩形之后，需要将其通过一系列变换转换成图片中最右边的标准立方体(canonical cub $[-1 ,1]^3$)

- 一系列变换指的是
  - 矩形移动到原点
  - X、Y、Z轴拉伸成\[-1, 1\]

$$
M_{ortho} =
\begin{bmatrix}
    \frac{2}{r-l} & 0 & 0 & 0 \\
    0 & \frac{2}{t-b} & 0 & 0 \\
    0 & 0 & \frac{2}{n-f} & 0 \\
    0 & 0 & 0 & 1 
\end{bmatrix} 
\begin{bmatrix}
    1 & 0 & 0 & -\frac{r+l}{2} \\
    0 & 1 & 0 & -\frac{t+b}{2} \\
    0 & 0 & 1 & -\frac{n+f}{2} \\
    0 & 0 & 0 & 1
\end{bmatrix}
$$

> 左边缩放矩阵、右边平移矩阵（操作顺序从右往左理解）  
> 暂不考虑旋转

这里对物体做了拉伸，未来还会做一次**视口变换**，**视口变换**时会再做一次拉伸

#### 透视投影 Perspective

理论上两条平行的先看起来相交了

![](./Image/17.png)

前置知识：点(x, y, z, 1)乘以k，得到(kx, ky, kz, k != 0)表示其实也是点(x, y, z, 1)，将k换成z，可以得到(xz, yz, $z^2$,z != 0)，也表示(x, y, z, 1)这个点  

> (1, 0, 0, 1)与(2, 0, 0, 2)表示同一个点

![](./Image/18.png)

- 透视投影分两步 
    1. 将Frustum平截头体转换成Cuboid矩形
    2. 进行一次正交投影

- 将Frustum平截头体转换成Cuboid矩形
  - n(near)平面的四个点不会发生变换
  - f(far)平面的z值不会发生变换，只是在平面内进行收缩
  - n、f平面的中心点不会发生变化

![](./Image/19.png)

通过侧面观察，更容易得到结论  

最左边的红点就是摄像机的位置，中间的红点就是n(near)平面，最右边的红点就是f(far)平面  

目标就是将(x, y, z) => (x, y\', z)，通过相似三角形可以推出计算公式

设$M_{persp}$为透视变换矩阵

设$M^{(4\times4)}_{persp \rightarrow ortho}$为透视变换成正交的变换矩阵

得出$M_{persp}=M_{ortho}M^{(4\times4)}_{persp \rightarrow ortho}$，即将模型先变换成正交可以用的矩形，再通过正交变换矩阵计算

$x`=\frac{n}{z}x,y`=\frac{n}{z}y$

$$
\begin{pmatrix}
    x \\ y \\ z \\ 1
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
    nx/x \\ ny/z \\ unknow \\ 1
\end{pmatrix} ==
\begin{pmatrix}
    nx \\ ny \\ still unknow \\ z
\end{pmatrix}
\\
M^{(4\times4)}_{persp \rightarrow ortho} 
\begin{pmatrix}
    x \\ y \\ z \\ 1
\end{pmatrix} = 
\begin{pmatrix}
    nx \\ ny \\ unknow \\ z
\end{pmatrix}
\Rightarrow
M^{(4\times4)}_{persp \rightarrow ortho} =
\begin{pmatrix}
    n & 0 & 0 & 0 \\
    0 & n & 0 & 0 \\
    ? & ? & ? & ? \\
    0 & 0 & 1 & 0
\end{pmatrix}
$$

> 透视变换矩阵最后一行完全可以是(0 0 0 z)，但是z是变量，到时候计算的时候还得实时带入z的真实值，对于计算机来说很麻烦，要开辟内存，还要传值，浪费资源

- 此时带入观察到的两个细节
  - 对近平面来说，(x, y, n, 1) (n表示近平面的z)与透视变换矩阵运算，其x、y、n值不变
  - 对远平面来说，(x, y, f, 1) (f表示远平名的z)与透视变换矩阵运算，其f值不变
  - 对远平面来说，(0, 0, f, 1) 与透视变换矩阵运算，其值不变，仍未(0, 0, f, 1)

$$
M^{(4\times4)}_{persp \rightarrow ortho} 
\begin{pmatrix}
    x \\ y \\ n \\ 1
\end{pmatrix} = 
\begin{pmatrix}
    x \\ y \\ n \\ 1 
\end{pmatrix} ==
\begin{pmatrix}
    nx \\ ny \\ n^2 \\ n 
\end{pmatrix}
\\
设M^{(4\times4)}_{persp \rightarrow ortho}第三行为
\begin{pmatrix}
    A & B & C & D
\end{pmatrix}
带入上述式子的计算中得
\begin{pmatrix}
    A & B & C & D
\end{pmatrix}
\begin{pmatrix}
    x \\ y \\ n \\ 1
\end{pmatrix} = n^2
\\
得到A=0, B=0, C*n + B = n^2
\\
M^{(4\times4)}_{persp \rightarrow ortho} 
\begin{pmatrix}
    0 \\ 0 \\ f \\ 1
\end{pmatrix} = 
\begin{pmatrix}
    0 \\ 0 \\ f \\ 1 
\end{pmatrix} ==
\begin{pmatrix}
    0 \\ 0 \\ f^2 \\ f
\end{pmatrix}
\\
带入前面推理(0, 0, C, D)式子中，得到 Cf + D = f^2
\\
\begin{matrix}
    Cn + D = n^2 \\
    Cf + D = f^2
\end{matrix}
\Longrightarrow
\begin{matrix}
    C = n + f \\
    D = -nf
\end{matrix}
\\
M^{(4\times4)}_{persp \rightarrow ortho} = 
\begin{pmatrix}
    n & 0 & 0 & 0 \\
    0 & n & 0 & 0 \\
    0 & 0 & n + f & -nf \\
    0 & 0 & 1 & 0
\end{pmatrix}
$$

将得到的矩阵与（x，y，z，1）相乘后z的值等于(-nf)*z^(-1)+(n+f),是个反比例函数，这个图像恒过（n，n）与（f，f），在n与f之间，z是下凹的，所以z变小了，即再f与n平面之间的点的z是会变小的

# 光栅化(Rasterization)

将三维空间的几何形体显示到屏幕上  
将投影的基本体分解为片段（像素）  

通过前面的视图变换、投影变换（正交、透视），我们得到了\[-1, 1\]^3的标准立方体

- 定义视锥需要的两个数据
  - 宽高比
  - 垂直的可视角度

![](./Image/20.png)

- **屏幕**：图形学中认为屏幕是一个数组，数组中每一个元素是一个像素
- **光栅**：Raster，就表示屏幕，光栅化(Rasterize)可以理解为把东西绘制在屏幕上
- **像素**：Pixel(Picture Element的缩写)
- **屏幕空间**：在屏幕上定义的坐标系，屏幕左下角为(0, 0)原点，向上为Y轴正方向，向右为X轴正方向
  - 坐标从0开始，而不是从1开始
  - 屏幕的所有的像素是从(0, 0)到(width - 1, height - 1)
  - (x, y)点像素的中心在(x + 0.5, y + 0.5)上
  - 屏幕表示的范围从(0, 0)到(width, height)

- 在不考虑Z轴的情况下，将\[-1, 1\]的矩阵的x、y坐标映射到屏幕中
  - 移动到屏幕中心
  - 缩放一下
$$
M_{viewport} =
\begin{pmatrix}
    \frac{width}{2} & 0 & 0 & \frac{width}{2} \\
    0 & \frac{height}{2} & 0 & \frac{height}{2} \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{pmatrix}
$$

- 图形学广泛使用三角形
  - 三角形是最基础的多边形
  - 任何多边形都可以被拆分成多个三角形
  - 三角形三个点肯定在同一个平面
  - 三角形内外定义清晰（多边形可能有洞 圆环，可能不是凸包）
  - 三角形三个点定义不同属性，三角形内部的各个点可以逐渐渐变

利用像素中心，对屏幕空间进行采样

![](./Image/21.png)

$$
inside(tri, x, y) =
\begin{cases}
    1, Point(x, y) 在 tri 这个形状中 \\
    0, Point(x, y) 不在 tri 形状中
\end{cases}
$$

```cpp
for(int x = 0; x < width; ++x){
    for(int y = 0; y < height; ++y){
        image[x][y] = inside(tri, x+0.5, y+0.5)
    }
}
```

> 通过上述代码就可以知道(x, y)像素是否在多边形中，因为像素中心坐标是(x+0.5, y+0.5)，所以传入的是像素中心坐标

那么如何判断像素点是否在三角形内呢？ 最开始将的**叉乘**就可以用到了  

判断像素是否在三角形中不用判断(0, 0)到(width, height)中所有的像素，只需要判断三角形三个点中最高、最低、最左、最右所围城的矩阵即可，这个矩阵被称为**包围盒**



# 几何

如何表示光滑的曲线、曲面、将简单曲面通过细分的方法得到复杂曲面、形状发生变化时面如何变化、如何保持物体的拓扑结构…

# 光线追踪（Ray Tracing）

# 动画模拟、仿真

